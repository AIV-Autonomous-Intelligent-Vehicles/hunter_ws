#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import ipaddress
import json
import logging
# Only needed because inet_ntop is not available on Windows.
import os
import re
import socket
import struct
import sys
import urllib.request


# allow setting an indent level
# source: stackoverflow.com/a/34401306
class CustomAdapter(logging.LoggerAdapter):
    indent_level = 0
    indent_string = "    "
    def increment_indent_level(self):
        self.indent_level += 1
    def decrement_indent_level(self):
        self.indent_level -= 1
    def set_indent_level(self, indent_level):
        self.indent_level = indent_level
    def process(self, msg, kwargs):
        return '{i}{m}'.format(i=self.indent_string*self.indent_level, m=msg), kwargs

# logger = logging.getLogger(__name__) # replaced by:
logger = CustomAdapter(logging.getLogger(__name__), {})

#-------------------------------------------------------------------------------
# Constants
#-------------------------------------------------------------------------------
DEFAULT_SOCKET_TIMEOUT = 0.2

OS1_64_MODEL = 'OS-1-64'
GENERIC = 'Ouster Sensor'
OS1_PREFIX = 'os1-'
OS_PREFIX = 'os-'
DEFAULT_COMMAND_PORT = 7501

LINK_LOCAL_ADDR_FMT = '{}%{}'
MDNS_PACKET_ID = 0x1001
LOCAL_SUFFIX = '.local'
QUERY_ALL = '_roger._tcp' + LOCAL_SUFFIX

FIELD_ADDR = 'address'
FIELD_FACING_ADDR = 'facing address'
FIELD_HOSTNAME = 'hostname'
FIELD_IFACE = 'network interface'
FIELD_IS_LIDAR = 'Ouster lidar'
FIELD_LIDAR_INFO = 'lidar information'

CATEGORY_NETWORK = 'network'

NETWORK_INFO_URL_FMT = 'http://{}/api/v1/system/{}'

#-------------------------------------------------------------------------------
# Generic Functions
#-------------------------------------------------------------------------------
def strip_iface(addr):
  '''
  Strip the interface from IPv6 addresses (XXXX::YYYY::...%<iface>).
  '''
  if isinstance(addr, str):
    try:
      addr, _ = addr.split('%', 1)
    except ValueError:
      pass
  return addr



#-------------------------------------------------------------------------------
def add_iface(addr, iface):
  '''
  Add the network interface if the address is IPv6.
  '''
  if is_ipv6(addr):
    addr = LINK_LOCAL_ADDR_FMT.format(strip_iface(addr), iface)
  return addr



#-------------------------------------------------------------------------------
def strip_mask(addr):
  if isinstance(addr, str):
    try:
      addr, _ = addr.split('/', 1)
    except ValueError:
      pass
  return addr



#-------------------------------------------------------------------------------
def is_ipv6(addr):
   '''
   Check if an address is an IPv6 address. This accepts instance if ipaddress
   classes and strings.
   '''
   if isinstance(addr, ipaddress.IPv6Address):
     return True
   elif isinstance(addr, ipaddress.IPv4Address):
     return False
   else:
     addr = strip_iface(addr)
     try:
       ipaddr = ipaddress.ip_address(addr)
     except ValueError:
       return False
     else:
       if isinstance(ipaddr, ipaddress.IPv6Address):
         return True
       #  elif isinstance(addr, ipaddress.IPv4Address):
       #    return False
       else:
         return False

def get_ip(addr):
  # Windows doesn't implement inet_ntop, despite it being part of the standard
  # library.
  #  try:
  #    return socket.inet_ntop(socket.AF_INET6, addr)
  #  except ValueError:
  #    pass
  #  try:
  #    return socket.inet_ntop(socket.AF_INET, addr)
  #  except ValueError:
  #    pass
  n = len(addr)
  if n == 16:
    chunks = (
      '{:02x}{:02x}'.format(ord(addr[2*i]), ord(addr[2*i+1]))
      for i in range(8)
    )
    chunks = (c.lstrip('0') if c != '0000' else '0' for c in chunks)
    ipaddr_str = ':'.join(chunks)
    ipaddr_str = re.sub(r':0:(?:0:)*0:', '::', ipaddr_str, count=1)
    return(ipaddr_str)
  elif n == 4:
    return ('{:d}'.format(ord(b)) for b in addr)

  raise ValueError('{} does not appear to be a valid IPv4 or IPv6 IP address'.format(addr))




#-------------------------------------------------------------------------------
# Exceptions
#-------------------------------------------------------------------------------
class QueryError(Exception):
  def __init__(self, msg):
    self.msg = msg

  def __str__(self, *args, **kwargs):
    return self.msg

#-------------------------------------------------------------------------------
# MDNSPacketHeader
#-------------------------------------------------------------------------------
class MDNSPacketHeader():
  FORMAT = '!H2sHHHH'
  FLAG_FORMAT = '>H'
  #-----------------------------------------------------------------------------
  def __init__(self, ID=MDNS_PACKET_ID, flags=0, qdcount=0, ancount=0, nscount=0, arcount=0):
    self.ID = ID
    self.flags = flags
    self.qdcount = qdcount
    self.ancount = ancount
    self.nscount = nscount
    self.arcount = arcount

  #-----------------------------------------------------------------------------
  def pack(self):
    return struct.pack(
      self.FORMAT,
      self.ID,
      struct.pack(self.FLAG_FORMAT, self.flags),
      self.qdcount,
      self.ancount,
      self.nscount,
      self.arcount
    )

  #-----------------------------------------------------------------------------
  def unpack(self, header):
    self.ID, flags, self.qdcount, self.ancount, self.nscount, self.arcount = struct.unpack(self.FORMAT, header)
    self.flags, = struct.unpack(self.FLAG_FORMAT, flags)
    return self



#-------------------------------------------------------------------------------
# MDNSPacket
#-------------------------------------------------------------------------------
class MDNSPacket():
  #-----------------------------------------------------------------------------
  def __init__(self, data=None):
    self.data = data
    self.offset = 0
    self.header = None
    self.queries = list()
    self.answers = list()

  #-----------------------------------------------------------------------------
  @classmethod
  def get_question(cls, question, qtype=0x00ff, qclass=0x8001):
    question = question.encode('utf-8')
    qname = b''
    for label in question.split(b'.'):
      l = len(label)
      fmt = '!B{:d}s'.format(l)
      qname += struct.pack(fmt, l, label)
    return qname + struct.pack('!BHH', 0, qtype, qclass)

  #-----------------------------------------------------------------------------
  @classmethod
  def get_query(cls, ID, *questions):
    # 8: recursive
    flags = (1 << 8)
    header = MDNSPacketHeader(ID=ID, flags=flags, qdcount=len(questions))
    return header.pack() +  b''.join(cls.get_question(q) for q in questions)

  #-----------------------------------------------------------------------------
  def get_name(self):
    data = self.data[self.offset:]
    offset = 0
    name = b''
    # If the first 2 bits are set then the remaining 6 bits and the following
    # byte indicate an offset to another name in the packet data.
    # 0b11000000
    compression_pointer_bits = 0xc0

    while data and data[0] != 0:
      first_byte, = struct.unpack('B', data[0:1])

      if (first_byte & compression_pointer_bits == compression_pointer_bits):
        current_offset = self.offset
        compression_pointer_mask = 0xff ^ compression_pointer_bits
        try:
          second_byte, = struct.unpack('B', data[1:2])
          self.offset = (first_byte & compression_pointer_mask) * 0x100 + second_byte
          name = self.get_name()
        except IndexError:
          logger.warning('malformed MDNS packet detected')
        finally:
          self.offset = current_offset
        self.offset += 2
        return name

      if name:
        name += b'.'
      n, = struct.unpack('!B', data[0:1])
      name += data[1:1+n]
      offset += 1 + n
      data = data[1+n:]
    # +1 for the terminating null byte in the name field
    self.offset += offset + 1
    return name

  #-----------------------------------------------------------------------------
  def parse_query(self):
    qname = self.get_name()
    data = self.data[self.offset:]
    try:
      qtype, qclass = struct.unpack('!HH', data[:4])
      self.offset += 4
      return qname, qtype, qclass
    except (IndexError, struct.error) as e:
      logger.warning('failed to parse MDNS query: {}'.format(e))
    return None, None, None,

  #-----------------------------------------------------------------------------
  def parse_answer(self):
    name = self.get_name()
    data = self.data[self.offset:]
    try:
      typ, cls, ttl, rdlength = struct.unpack('!HHIH', data[:10])
      data = data[10:]
      rdata = data[:rdlength]
      data = data[rdlength:]
      self.offset += 10 + rdlength
      return name, typ, cls, ttl, rdlength, rdata
    except (IndexError, struct.error) as e:
      logger.warning('failed to parse MDNS answer: {}'.format(e))
    return None, None, None, None, None, None

  #-----------------------------------------------------------------------------
  def parse_packet(self, data=None):
    if data is None:
      data = self.data
    else:
      self.data = data

    self.header = MDNSPacketHeader().unpack(data[:12])
    self.offset = 12
    self.queries = [self.parse_query() for _ in range(self.header.qdcount)]
    self.answers = [self.parse_answer() for _ in range(self.header.ancount)]



#-------------------------------------------------------------------------------
# MDNSSocket
#-------------------------------------------------------------------------------
class MDNSSocket():
  KIND = socket.SOCK_DGRAM
  PROTO = socket.IPPROTO_UDP

  #-----------------------------------------------------------------------------
  def __init__(self, iface, addr='ff02::fb', port=5353, ttl=2, timeout=DEFAULT_SOCKET_TIMEOUT):
    self.iface = iface
    self.port = port
    self.ttl = ttl
    self.set_addr(addr)
    self.addr_info = None
    self.timeout = timeout

  #-----------------------------------------------------------------------------
  def set_addr(self, addr):
    self.addr = addr
    self.is_ipv6 = is_ipv6(addr)
    self.family = socket.AF_INET6 if self.is_ipv6 else socket.AF_INET

  #-----------------------------------------------------------------------------
  def get_addr(self):
    return LINK_LOCAL_ADDR_FMT.format(self.addr, self.iface)

  #-----------------------------------------------------------------------------
  def send(self, data):
    self.sock.sendto(data, self.addr_info)

  #-----------------------------------------------------------------------------
  def recv(self):
    while True:
      # recvfrom returns the response and remote address
      try:
        yield self.sock.recvfrom(1024)
      except socket.timeout:
        return

  #-----------------------------------------------------------------------------
  def __enter__(self):
    family = self.family
    kind = self.KIND
    proto = self.PROTO

    self.sock = sock = socket.socket(family, kind, proto).__enter__()
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.settimeout(self.timeout)

    logger.debug('getting address information for address {} and port {}'.format(self.get_addr(), self.port))
    addr_infos = tuple(
      addr for addr in socket.getaddrinfo(self.get_addr(), self.port)
      if addr[0] == family
      #  and addr[1] == kind
    )
    try:
      self.addr_info = addr_infos[0][-1]
    except IndexError:
      raise QueryError('failed to get address information for address {} and port {}'.format(self.get_addr(), self.port))
    logger.debug('using address information {}'.format(self.addr_info))


    # Windows doesn't have IPPROTO_IPV6 for whatever reason.
    #  if family == socket.AF_INET6:
    #    ttl_packed = struct.pack('@i', self.ttl)
    #    sock.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, ttl_packed)
    #  else:
    #    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, self.ttl)

    return self

  #-----------------------------------------------------------------------------
  def __exit__(self, typ, value, traceback):
    self.sock.__exit__(typ, value, traceback)



#-------------------------------------------------------------------------------
def parse_args(args=None):
  try:
    prog = os.path.basename(sys.argv[0])
    default_args = sys.argv[1:]
  except AttributeError:
    prog = 'OusterSensorLocator'
    default_args = []

  if args is None:
    args = default_args

  parser = argparse.ArgumentParser(prog=prog, description='Get the IP address of an Ouster sensor and the local address that faces it.')
  parser.add_argument('--id', metavar='<Ouster serial number>', help='The serial number of the target sensor (printed on the sensor). Without this, the first located sensor will be returned.')
  parser.add_argument('--iface', metavar='<network interface name>', help='The network interface through which to query the sensor. This is optional if the Python netifaces package is installed.')
  parser.add_argument('--timeout', default=DEFAULT_SOCKET_TIMEOUT, type=float, help='The time to wait for an MDNS response, in seconds. Default: %(default)s')
  parser.add_argument('--port', default=DEFAULT_COMMAND_PORT, type=int, help='The lidar command port. Default: %(default)s')
  parser.add_argument('--scan', action='store_true', help='Scan for connected Ouster sensors.')
  parser.add_argument('--search-site-packages', action='append', default=[], help='Scan given directories for "site-packages" sub-directory.')
  parser.add_argument('--out', help='Save the output to a file instead of printing it.')
  parser.add_argument('--log', default=None, help='Save the logging to a file.')
  return parser.parse_args(args=args)



#-------------------------------------------------------------------------------
def query_mdns_via_interface(iface, query_str, packet_id=0x1001, timeout=DEFAULT_SOCKET_TIMEOUT, add_local_suffix=True):
  '''
  Send an MDNS query. For Ouster sensors, the query should be the Ouster serial
  number prefixed with "os1-" and suffixed with ".local", for example
  "os1-991909000651.local".

  The returned IP is an instance of an ipaddress module class if the name was fully resolved, a string if it was resolved to a hostname, or None if resolution failed.
  '''
  yielded_at_least_one = False

  # Ensure the local suffix is added.
  if add_local_suffix and not query_str.endswith(LOCAL_SUFFIX):
    query_str = query_str + LOCAL_SUFFIX

  with MDNSSocket(iface, timeout=timeout) as msock:
    mpacket = MDNSPacket()
    query = mpacket.get_query(packet_id, query_str)
    msock.send(query)
    logger.info("Send MDNS query '{}'".format(query_str))
    received_a_response = False
    for response, remote_addr in msock.recv():
      received_a_response = True
      mpacket.parse_packet(response)
      for ans in mpacket.answers:
        if ans[0].decode('ascii') == query_str:
          if query_str == QUERY_ALL:
            answer = ans[-1].strip(b'\x1a\x10\x18\xc0\x0c').decode('ascii')
            logger.info("MDNS query '{}' returned answer '{}'".format(query_str, answer))
            try:
              words = answer.split(' ')
              if (len(words)>1):
                if (words[0] == OS1_64_MODEL): #Before firmware v1.13
                  hostname = words[1]
                  logger.increment_indent_level()
                  logger.info("Infering hostname '{}'".format(hostname))
                  logger.decrement_indent_level()
                  yield {
                    FIELD_HOSTNAME : hostname,
                    FIELD_IFACE    : iface,
                    FIELD_IS_LIDAR : True
                  }
                elif (words[0] + " " + words[1] == GENERIC): #After firmware v1.13
                  # Depending on the firmware version, the hostname is not always the same
                  # to handle all cases, all results are return for this query.
                  serial_number = words[2]
                  hostnames, _ = get_potential_lidar_hostname(serial_number)
                  for hostname in hostnames:
                    logger.increment_indent_level()
                    logger.info("Infering hostname '{}'".format(hostname))
                    yield {
                      FIELD_HOSTNAME : hostname,
                      FIELD_IFACE    : iface,
                      FIELD_IS_LIDAR : True
                    }
                    logger.decrement_indent_level()

                yielded_at_least_one = True
            except ValueError:
              continue
          else:
            try:
              addr = ipaddress.ip_address(ans[-1])
            except ValueError:
              continue
            else:
              # Ensure the interface is suffixed to IPv6 addresses in case they are link-local.
              if is_ipv6(addr):
                addr = LINK_LOCAL_ADDR_FMT.format(addr, iface)

              logger.info("MDNS query '{}' returned address '{}'".format(query_str, addr))
              yield {
                FIELD_ADDR  : addr,
                FIELD_IFACE : iface
              }
              yielded_at_least_one = True

    if not received_a_response:
      logger.info("query '{}' via network interface '{}' timed out with 0 responses ({:0.2f}s)".format(query_str, iface, timeout))

    elif not yielded_at_least_one:
      logger.warning("MDNS query '{}' on interface '{}' returned no results".format(query_str, iface))



#-------------------------------------------------------------------------------
def get_ifaces():
  import platform
  if platform.system() == 'Windows':
    import subprocess
    si = subprocess.STARTUPINFO()
    si.dwFlags |= subprocess.STARTF_USESHOWWINDOW
    si.wShowWindow = subprocess.SW_HIDE
    try:
      response = subprocess.check_output(('route', 'print'), startupinfo=si).decode('utf-8', errors='replace')
    except subprocess.CalledProcessError:
      raise QueryError('error: failed to determine available network interfaces')
    else:
      ifaces = list()
      for line in response.split('\n'):
        m = re.match(r'^\s*(\d+)\.\.', line)
        if m:
          ifaces.append(m.group(1))
      return ifaces

  else:
    try:
      import netifaces
    except ImportError:
      raise QueryError('error: no interface given but "netifaces" module could not be imported')
    else:
      ifaces = netifaces.interfaces()
      if not ifaces:
        raise QueryError('error: "netifaces" module returned no network interfaces')
      return ifaces

#-------------------------------------------------------------------------------
def query_mdns(*args, iface=None, **kwargs):
  '''
  A wrapper around query_mdns_via_interface with support for auto-detecting
  network interfaces if the netifaces module is installed and no interface is
  given.
  '''
  ifaces = get_ifaces() if iface is None else (iface,)

  for iface in ifaces:
    logger.info('querying devices via network interface {}'.format(iface))
    logger.increment_indent_level()
    try:
      yield from query_mdns_via_interface(iface, *args, **kwargs)
    except (QueryError, socket.gaierror, OSError) as e:
      logger.info('no devices found via network interface {}: {}'.format(iface, e))
    logger.decrement_indent_level()



#-------------------------------------------------------------------------------
def get_potential_lidar_hostname(lidar_id):
  '''
  Return the list of potential hostname if the lidar_id seems valid.
  The lidar_id could be the hostname or the serial number.

  In case the serial number is provided the potential hostname are:
  - 'os-<serial number>'
  - 'os1-<serial number>'

  In case you already provide a valid hostname, this same hostname is return.
  '''
  is_lidar = False
  hostname = []
  if lidar_id.startswith(OS_PREFIX) or lidar_id.startswith(OS1_PREFIX):
    hostname.append(lidar_id)
    is_lidar = True
  elif lidar_id.isdigit():
    for prefix in [OS1_PREFIX, OS_PREFIX]:
      hostname.append('{}{}'.format(prefix, lidar_id))
    is_lidar = True
  return hostname, is_lidar



#-------------------------------------------------------------------------------
def get_lidar_facing_ip(lidar_ip, command_port=DEFAULT_COMMAND_PORT, timeout=DEFAULT_SOCKET_TIMEOUT):
  ipv6 = is_ipv6(lidar_ip)
  family = socket.AF_INET6 if ipv6 else socket.AF_INET
  kind = socket.SOCK_STREAM
  proto = socket.IPPROTO_TCP

  if not isinstance(lidar_ip, str) and lidar_ip is not None:
    lidar_ip = str(lidar_ip)

  with socket.socket(family, kind, proto) as sock:
    sock.settimeout(timeout)
    addr_infos = tuple(
      addr for addr in socket.getaddrinfo(lidar_ip, command_port)
      if addr[0] == family
      #  and addr[1] == kind
    )
    try:
      addr_info = addr_infos[0][-1]
    except IndexError:
      raise QueryError('error: failed to resolve address and port ({}, {})'.format(lidar_ip, command_port))
      return

    try:
      logger.debug('attempting to connect to {} on port {}'.format(lidar_ip, command_port))
      sock.connect(addr_info)
      return sock.getsockname()[0]
    except (OSError, socket.error) as e:
      raise QueryError('error: failed to connect to {} on port {} [{}]'.format(lidar_ip, command_port, e))




#-------------------------------------------------------------------------------
def get_lidar_info(lidar_ip, timeout=DEFAULT_SOCKET_TIMEOUT):
  ipv6 = is_ipv6(lidar_ip)
  categories = (CATEGORY_NETWORK,) # 'firmware')
  info = dict()
  for category in categories:
    # format ip to be usable in url. see https://en.wikipedia.org/wiki/IPv6_address#Use_of_zone_indices_in_URIs
    url_formated_ip = '[' + lidar_ip.replace('%', '%25') + ']' if ipv6 else lidar_ip
    url = NETWORK_INFO_URL_FMT.format(url_formated_ip, category)
    logger.info('attempting to retrieve Ouster {} information from {}'.format(category, url))
    try:
      with urllib.request.urlopen(url, timeout=timeout) as f:
        info[category] = json.load(f)
        logger.info('The sensor return: {}'.format(info[category]))
    except (urllib.error.URLError, json.JSONDecodeError ) as e:
      logger.info('failed to retrieve information from {}: {}'.format(url, e))
  return info




#-------------------------------------------------------------------------------
def process_result(results, command_port=DEFAULT_COMMAND_PORT, timeout=DEFAULT_SOCKET_TIMEOUT):
  sensors = []
  for result in results:

    # remove result than aren't a lidar
    if not result.get(FIELD_IS_LIDAR, False):
      continue

    sensor = {}

    try:
      address = result[FIELD_ADDR]
      interface = result[FIELD_IFACE]

      # copy information already available
      sensor[FIELD_HOSTNAME] = result[FIELD_HOSTNAME]
      sensor[FIELD_IFACE] = interface
      sensor["ipv6"] = address


      try:
        facing_ip = get_lidar_facing_ip(address, command_port=command_port, timeout=timeout)
        sensor[FIELD_FACING_ADDR] = facing_ip
      except QueryError as e:
        logger.warning('failed to retrieve facing ip: {}'.format(e))

      # try to get additional information about the sensor like ipv4 address
      try:
        lidar_info = get_lidar_info(address, timeout=timeout)
        sensor[FIELD_LIDAR_INFO] = lidar_info
        ipv4_info = lidar_info[CATEGORY_NETWORK]["ipv4"]
        for address_type in ("addr", "link_local"):
          if address_type in ipv4_info:
            sensor["ipv4"] = strip_mask(ipv4_info[address_type])
            # RFC 3927 warns agains using multiple IPv4 addresses simultaneously, so break if one is found.
            # https://tools.ietf.org/html/rfc3927
            break
        else:
          logger.info("The sensor didn't provide a globale/private nor a link_local ipv4 address")
      except KeyError as e:
        logger.info("Error while getting the ipv4 address of the sensor: {}".format(e))
      except QueryError as e:
        logger.warning('failed to retrieve some information from sensor at {}, so no IPV4 will be available'.format(address))
    except KeyError:
      pass

    sensors.append(sensor)

  # add interface list to the results
  processed_results = {}
  processed_results["network interfaces detected"] = get_ifaces()
  processed_results["sensors"] = sensors

  return processed_results



#-------------------------------------------------------------------------------
def display_scan_result(result):
  """Display the result to the user the same way it's done by avahi-browse on linux"""

  logger.info("*************************************************")
  logger.info("******************** SUMMARY ********************")
  logger.info("*************************************************")

  interfaces = result["network interfaces detected"]
  logger.info("Found {} network interface(s) : {}".format(len(interfaces), interfaces))

  sensors = result["sensors"]
  if not sensors:
    logger.info("The scan failed. No sensor found")
    return
  logger.info("The scan succeed. {} sensor(s) found".format(len(sensors)))

  logger.info("Interface\tIPv4\t\tIpv6\t\t\t\tHostname")
  for sensor in sensors:
    interface = sensor[FIELD_IFACE]
    ipv4 = sensor.get("ipv4")
    ipv6 = sensor.get("ipv6")
    hostname = sensor[FIELD_HOSTNAME]
    logger.info("{}\t{}\t{}\t{}".format(interface, ipv4, ipv6, hostname))



#-------------------------------------------------------------------------------
def search_site_packages(path):
  path = os.path.abspath(path)
  name = 'site-packages'
  for root, dirs, files in os.walk(path):
    if name in dirs:
      yield os.path.join(root, name)

#-------------------------------------------------------------------------------
def main(args=None, as_json=True, pretty_json=False):
  pargs = parse_args(args=args)

  logging.basicConfig(
    filename = pargs.log,
    filemode='w',
    level=logging.INFO,
    style='{',
    format='[{asctime}] {levelname:7s} {message}',
    datefmt='%Y-%m-%d %H:%M:%S'
  )

  for path in pargs.search_site_packages:
    for sp in search_site_packages(path):
      logger.info('appending Python path: {}'.format(sp))
      sys.path.append(sp)

  iface = pargs.iface
  timeout = pargs.timeout
  command_port = pargs.port

  results = list()

  if not pargs.id:
    pargs.scan = True

  if pargs.scan:
    scan_results = query_mdns(QUERY_ALL, iface=iface, timeout=timeout)
    for scan_result in scan_results:
      logger.increment_indent_level()
      for nested_result in query_mdns_via_interface(scan_result[FIELD_IFACE], scan_result[FIELD_HOSTNAME], timeout=timeout):
        results.append(scan_result.copy())
        results[-1].update(nested_result)
      logger.decrement_indent_level()

  if pargs.id:
    querys, is_lidar = get_potential_lidar_hostname(pargs.id)
    for query in querys:
      for result in query_mdns(query, iface=iface, timeout=timeout):
        result[FIELD_IS_LIDAR] = is_lidar
        results.append(result)

  results = process_result(results, command_port)

  display_scan_result(results)


  dump_args = dict(indent=2, sort_keys=True) if pretty_json else dict()

  if pargs.out:
    with open(pargs.out, 'w') as f:
      json.dump(results, f, **dump_args)
    return

  if as_json:
    results = json.dumps(results, **dump_args)

  return results

#-------------------------------------------------------------------------------
def safe_main(*posargs, **kwargs):
  try:
    return main(*posargs, **kwargs)
  except Exception as e:
    logger.error(e)
    if kwargs.get('as_json', True):
      return '{}'
    else:
      return dict()

#-------------------------------------------------------------------------------
if __name__ == '__main__':
  try:
    results = main(args=None, as_json=True, pretty_json=True)
  except (KeyboardInterrupt,):
    pass
  except (QueryError,) as e:
    sys.exit(str(e))
  else:
    if results:
      print(results)

